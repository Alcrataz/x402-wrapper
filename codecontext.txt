x402
 coinbase GitHub x402 readme, im using their technology x402
# x402 payments protocol

> "1 line of code to accept digital dollars. No fee, 2 second settlement, $0.001 minimum payment."

```typescript
app.use(
  // How much you want to charge, and where you want the funds to land
  paymentMiddleware("0xYourAddress", { "/your-endpoint": "$0.01" })
);
// That's it! See examples/typescript/servers/express.ts for a complete example. Instruction below for running on base-sepolia.
```

## Philosophy

Payments on the internet are fundamentally flawed. Credit Cards are high friction, hard to accept, have minimum payments that are far too high, and don't fit into the programmatic nature of the internet.
It's time for an open, internet-native form of payments. A payment rail that doesn't have high minimums + % based fee. Payments that are amazing for humans and AI agents.

## Principles

- **Open standard:** the x402 protocol will never force reliance on a single party
- **HTTP Native:** x402 is meant to seamlessly complement the existing HTTP request made by traditional web services, it should not mandate additional requests outside the scope of a typical client / server flow.
- **Chain and token agnostic:** we welcome contributions that add support for new chains, signing standards, or schemes, so long as they meet our acceptance criteria laid out in [CONTRIBUTING.md](https://github.com/coinbase/x402/blob/main/CONTRIBUTING.md)
- **Trust minimizing:** all payment schemes must not allow for the facilitator or resource server to move funds, other than in accordance with client intentions
- **Easy to use:** x402 needs to be 10x better than existing ways to pay on the internet. This means abstracting as many details of crypto as possible away from the client and resource server, and into the facilitator. This means the client/server should not need to think about gas, rpc, etc.

## Ecosystem

The x402 ecosystem is growing! Check out our [ecosystem page](https://x402.org/ecosystem) to see projects building with x402, including:

- Client-side integrations
- Services and endpoints
- Ecosystem infrastructure and tooling
- Learning and community resources

Want to add your project to the ecosystem? See our [demo site README](https://github.com/coinbase/x402/tree/main/typescript/site#adding-your-project-to-the-ecosystem) for detailed instructions on how to submit your project.

**Roadmap:** see [ROADMAP.md](https://github.com/coinbase/x402/blob/main/ROADMAP.md)

## Terms:

- `resource`: Something on the internet. This could be a webpage, file server, RPC service, API, any resource on the internet that accepts HTTP / HTTPS requests.
- `client`: An entity wanting to pay for a resource.
- `facilitator server`: A server that facilitates verification and execution of on-chain payments.
- `resource server`: An HTTP server that provides an API or other resource for a client.

## Technical Goals:

- Permissionless and secure for clients and servers
- Gasless for client and resource servers
- Minimal integration for the resource server and client (1 line for the server, 1 function for the client)
- Ability to trade off speed of response for guarantee of payment
- Extensible to different payment flows and chains

## V1 Protocol

The `x402` protocol is a chain agnostic standard for payments on top of HTTP, leverage the existing `402 Payment Required` HTTP status code to indicate that a payment is required for access to the resource.

It specifies:

1. A schema for how servers can respond to clients to facilitate payment for a resource (`PaymentRequirements`)
2. A standard header `X-PAYMENT` that is set by clients paying for resources
3. A standard schema and encoding method for data in the `X-PAYMENT` header
4. A recommended flow for how payments should be verified and settled by a resource server
5. A REST specification for how a resource server can perform verification and settlement against a remote 3rd party server (`facilitator`)
6. A specification for a `X-PAYMENT-RESPONSE` header that can be used by resource servers to communicate blockchain transactions details to the client in their HTTP response

### V1 Protocol Sequencing

![](./static/x402-protocol-flow.png)

The following outlines the flow of a payment using the `x402` protocol. Note that steps (1) and (2) are optional if the client already knows the payment details accepted for a resource.

1. `Client` makes an HTTP request to a `resource server`.

2. `Resource server` responds with a `402 Payment Required` status and a `Payment Required Response` JSON object in the response body.

3. `Client` selects one of the `paymentRequirements` returned by the server response and creates a `Payment Payload` based on the `scheme` of the `paymentRequirements` they have selected.

4. `Client` sends the HTTP request with the `X-PAYMENT` header containing the `Payment Payload` to the resource server.

5. `Resource server` verifies the `Payment Payload` is valid either via local verification or by POSTing the `Payment Payload` and `Payment Requirements` to the `/verify` endpoint of a `facilitator server`.

6. `Facilitator server` performs verification of the object based on the `scheme` and `network` of the `Payment Payload` and returns a `Verification Response`.

7. If the `Verification Response` is valid, the resource server performs the work to fulfill the request. If the `Verification Response` is invalid, the resource server returns a `402 Payment Required` status and a `Payment Required Response` JSON object in the response body.

8. `Resource server` either settles the payment by interacting with a blockchain directly, or by POSTing the `Payment Payload` and `Payment PaymentRequirements` to the `/settle` endpoint of a `facilitator server`.

9. `Facilitator server` submits the payment to the blockchain based on the `scheme` and `network` of the `Payment Payload`.

10. `Facilitator server` waits for the payment to be confirmed on the blockchain.

11. `Facilitator server` returns a `Payment Execution Response` to the resource server.

12. `Resource server` returns a `200 OK` response to the `Client` with the resource they requested as the body of the HTTP response, and a `X-PAYMENT-RESPONSE` header containing the `Settlement Response` as Base64 encoded JSON if the payment was executed successfully.

### Type Specifications

#### Data types

**Payment Required Response**

```json5
{
  // Version of the x402 payment protocol
  x402Version: int,

  // List of payment requirements that the resource server accepts. A resource server may accept on multiple chains, or in multiple currencies.
  accepts: [paymentRequirements]

  // Message from the resource server to the client to communicate errors in processing payment
  error: string
}
```

**paymentRequirements**

```json5
{
  // Scheme of the payment protocol to use
  scheme: string;

  // Network of the blockchain to send payment on
  network: string;

  // Maximum amount required to pay for the resource in atomic units of the asset
  maxAmountRequired: uint256 as string;

  // URL of resource to pay for
  resource: string;

  // Description of the resource
  description: string;

  // MIME type of the resource response
  mimeType: string;

  // Output schema of the resource response
  outputSchema?: object | null;

  // Address to pay value to
  payTo: string;

  // Maximum time in seconds for the resource server to respond
  maxTimeoutSeconds: number;

  // Address of the EIP-3009 compliant ERC20 contract
  asset: string;

  // Extra information about the payment details specific to the scheme
  // For `exact` scheme on a EVM network, expects extra to contain the records `name` and `version` pertaining to asset
  extra: object | null;
}
```

**`Payment Payload`** (included as the `X-PAYMENT` header in base64 encoded json)

```json5
{
  // Version of the x402 payment protocol
  x402Version: number;

  // scheme is the scheme value of the accepted `paymentRequirements` the client is using to pay
  scheme: string;

  // network is the network id of the accepted `paymentRequirements` the client is using to pay
  network: string;

  // payload is scheme dependent
  payload: <scheme dependent>;
}
```

#### Facilitator Types & Interface

A `facilitator server` is a 3rd party service that can be used by a `resource server` to verify and settle payments, without the `resource server` needing to have access to a blockchain node or wallet.

**POST /verify**. Verify a payment with a supported scheme and network:

- Request body JSON:
  ```json5
  {
    x402Version: number;
    paymentHeader: string;
    paymentRequirements: paymentRequirements;
  }
  ```
- Response:
  ```json5
  {
    isValid: boolean;
    invalidReason: string | null;
  }
  ```

**POST /settle**. Settle a payment with a supported scheme and network:

- Request body JSON:

  ```json5
  {
    x402Version: number;
    paymentHeader: string;
    paymentRequirements: paymentRequirements;
  }
  ```

- Response:

  ```json5
  {
    // Whether the payment was successful
    success: boolean;

    // Error message from the facilitator server
    error: string | null;

    // Transaction hash of the settled payment
    txHash: string | null;

    // Network id of the blockchain the payment was settled on
    networkId: string | null;
  }
  ```

**GET /supported**. Get supported payment schemes and networks:

- Response:
  ```json5
  {
    kinds: [
      {
        "scheme": string,
        "network": string,
      }
    ]
  }
  ```

### Schemes

A scheme is a logical way of moving money.

Blockchains allow for a large number of flexible ways to move money. To help facilitate an expanding number of payment use cases, the `x402` protocol is extensible to different ways of settling payments via its `scheme` field.

Each payment scheme may have different operational functionality depending on what actions are necessary to fulfill the payment.
For example `exact`, the first scheme shipping as part of the protocol, would have different behavior than `upto`. `exact` transfers a specific amount (ex: pay $1 to read an article), while a theoretical `upto` would transfer up to an amount, based on the resources consumed during a request (ex: generating tokens from an LLM).

See `specs/schemes` for more details on schemes, and see `specs/schemes/exact/scheme_exact_evm.md` to see the first proposed scheme for exact payment on EVM chains.

### Schemes vs Networks

Because a scheme is a logical way of moving money, the way a scheme is implemented can be different for different blockchains. (ex: the way you need to implement `exact` on Ethereum is very different from the way you need to implement `exact` on Solana).

Clients and facilitators must explicitly support different `(scheme, network)` pairs in order to be able to create proper payloads and verify / settle payments.

## Running example

**Requirements:** Node.js v24 or higher

1. From `examples/typescript` run `pnpm install` and `pnpm build` to ensure all dependent packages and examples are setup.

2. Select a server, i.e. express, and `cd` into that example. Add your server's ethereum address to get paid to into the `.env` file, and then run `pnpm dev` in that directory.

3. Select a client, i.e. axios, and `cd` into that example. Add your private key for the account making payments into the `.env` file, and then run `pnpm dev` in that directory.

You should see activities in the client terminal, which will display a weather report.

## Running tests

1. Navigate to the typescript directory: `cd typescript`
2. Install dependencies: `pnpm install`
3. Run the unit tests: `pnpm test`

This will run the unit tests for the x402 packages.

https://docs.cdp.coinbase.com/x402/welcome

im building a wrapper of this product 

Define Your Value Proposition
Focus on what businesses care about:

Revenue enablement: Help them monetize APIs, tools, or content with minimal effort.

Automation: Let them accept payments without managing wallets, keys, or blockchain infra.

Flexibility: Offer pricing models like pay-per-call, subscriptions, or usage tiers.

🛠️ 2. Build a Developer-Friendly SDK or Middleware
Create a plug-and-play library or gateway that businesses can drop into their stack:

Wrap x402’s HTTP flow into simple functions (e.g., requirePayment(), verifyPayment())

Support popular frameworks (Node.js, Python, Go, etc.)

Include templates for common use cases (API monetization, content paywalls, etc.)

🧮 3. Offer a Dashboard & Analytics Layer
Businesses love visibility. Provide:

Real-time payment logs

Usage metrics per endpoint or product

Revenue tracking and payout summaries

🔐 4. Add Optional Business Features
Differentiate your service with enterprise-grade options:

KYC/Geo restrictions: Use x402’s attestation roadmap to enforce compliance

Rate limiting & abuse protection

Multi-tenant support: Let platforms onboard multiple sellers

🚀 5. Monetize Your Wrapper
You can charge businesses by:

Monthly SaaS fees for access to your dashboard and tools

Per-transaction fees layered on top of x402’s fee-free Base network

Premium features like custom branding, SLA guarantees, or integrations

🧠 6. Target Specific Verticals
Position your service for high-value niches:

Fintech APIs (e.g., credit scoring, identity verification)

AI tools (e.g., model inference, data access)

Content platforms (e.g., pay-per-article or video)

Proxy aggregators (e.g., reselling third-party APIs)
┌────────────────────────────┐
│        Client SDKs         │
│ (JS, Python, Go, etc.)     │
└────────────┬───────────────┘
             │
┌────────────▼───────────────┐
│     Wrapper Gateway/API     │
│  (Express, FastAPI, etc.)   │
└────────────┬───────────────┘
             │
┌────────────▼───────────────┐
│     Payment Orchestrator    │
│  - Handles 402 responses    │
│  - Constructs payloads      │
│  - Talks to Facilitator     │
└────────────┬───────────────┘
             │
┌────────────▼───────────────┐
│     Facilitator Layer       │
│  - Coinbase-hosted or self  │
│  - Verifies & settles txs   │
└────────────┬───────────────┘
             │
┌────────────▼───────────────┐
│     Seller Resource/API     │
│  - Actual content/service   │
└────────────────────────────┘


Core Features of the Dashboard UI
🔐 Seller Onboarding
Connect wallet (Privy)

Register endpoints and set pricing ($0.1 per  1000 calls)

Choose payment schemes (e.g., exact, upto)

Select facilitator (Coinbase-hosted or custom)

📊 Revenue & Usage Analytics
Total earnings (USDC on Base)

Per-endpoint breakdown

Request volume over time

Failed payment attempts and error logs

⚙️ Endpoint Management
Add/edit/delete monetized endpoints

Set rate limits or access rules

Toggle endpoint visibility (public/private)

Attach metadata (description, tags, categories)

🧾 Payment Logs & Settlement History
View verified transactions

Track tx hashes and timestamps

Export logs for accounting or compliance

🌍 Compliance & Access Control
Geo-fencing (block or allow regions)

KYC enforcement (when facilitator supports attestations)

IP filtering and abuse detection

🧪 Testing & Simulation Tools
Simulate 402 flow with test wallets

Preview client experience

Debug payment payloads and facilitator responses

🧠 Bonus Features for Power Users
🧱 Multi-Tenant Support
Let platforms onboard multiple sellers

Each seller gets their own wallet, endpoints, and analytics

🧠 AI Agent Integration
View agent usage patterns

Offer agent-specific pricing or bundles

Monitor autonomous payments and service chaining

🛒 Service Discovery Registry
Public listing of x402-enabled endpoints

Searchable by category, price, or asset

Optional ratings or usage stats

�� Tech Stack Suggestions
Frontend: React + Tailwind 

Backend: Node.js/Express or FastAPI

Database: Supabase

Wallet Integration: Privy 

Facilitator API: Coinbase-hosted 

Strategy & Scoping
🎯 Define the Product Vision
Goal: Make x402 integration frictionless for API/content sellers

Core Value: Plug-and-play monetization, analytics, and compliance

Target Users: API providers, AI tool builders, content platforms

📦 Decide on MVP Scope
Start lean but impactful:

Seller onboarding (wallet + endpoint registration)

Pricing config per endpoint

Payment orchestration (handle 402, construct payload, verify)

Basic dashboard (usage logs, revenue tracking)

🛠️ Phase 2: Architecture & Tech Stack
🧱 Core Components
Component	Role
Client SDK	Handles payment flow, signing, retries
Wrapper Gateway	Intercepts requests, enforces pricing
Payment Engine	Constructs payloads, talks to facilitator
Dashboard UI	Seller control panel
Database	Stores endpoints, pricing, logs
 
🗓️ 4-Week Build Plan
Week 1: Core Wrapper Logic
✅ Build Express middleware to intercept 402 responses

✅ Integrate Coinbase facilitator /verify and /settle

✅ Construct and sign EIP-3009 payloads using x402 SDK

✅ Test end-to-end flow with a sample monetized API

Week 2: Seller Onboarding + Pricing
✅ Wallet connect (Privy or Wagmi)

✅ Endpoint registration form

✅ Pricing config per endpoint (e.g., $0.01/call)

✅ Store seller data in PostgreSQL or Supabase

Week 3: Dashboard UI
✅ Build React dashboard with Tailwind

✅ Display usage logs, tx hashes, and revenue

✅ Add endpoint management (edit/delete/toggle)

✅ Simulate test payments with dummy wallets

Week 4: SDK + Polish
✅ JS SDK for buyers (payAndFetch(url))

✅ CLI tool for testing endpoints

✅ Error handling, retries, and fallback logic

✅ Deploy to Vercel + Render or Railway

🧠 What You’ll Have by Month-End
A working wrapper that abstracts x402 complexity

A dashboard for sellers to monetize and track endpoints

A client SDK for buyers to pay and fetch resources

A deployable product that’s demo-ready and extensible

Your Locked-In Stack
Layer	Choice
Frontend	React + Tailwind
Backend	Node.js (Express)
Database	PostgreSQL (on VPS)
Wallet/Auth	Privy
Payments	x402 + Coinbase Facilitator
SDK	x402 TypeScript SDK

folder structure

x402-wrapper/
├── README.md
├── LICENSE
├── .env.local
├── package.json
├── tsconfig.json
├── package-lock.json
│
├── apps/
│   ├── dashboard/          # React frontend for sellers
     |     |__ component/RegisterEndpointForm.tsx , SellerEndpointslists.tsx
           |__ pages/ _app.tsx , dashboard.tsx       
│   └── api-gateway/        # Express/FastAPI backend wrapper
│
├── sdk/
│   ├── client/             # JS SDK for buyers (payAndFetch)
│   └── server/             # Middleware for sellers (paymentMiddleware)
│
├──lib/supabase.ts
├── core/
│   ├── orchestrator/       # Payment flow logic (detect 402, construct payload)
│   ├── facilitator/        # Facilitator API wrapper (verify/settle)
│   └── utils/              # Shared helpers (signing, encoding, etc.)
│
├── db/
│   ├── schema.sql          # PostgreSQL schema for endpoints, logs
│   └── migrations/         # Migration scripts
│
├── public/
│   └── assets/             # Static files for dashboard
│
├── scripts/
│   └── cli.ts              # CLI tool for testing endpoints
│
├── apigateway
├── node_modules
└── docs/
    ├── architecture.md     # System overview
    ├── onboarding.md       # Seller setup guide
    └── api-reference.md    # SDK and gateway endpoints

ill paste you the code for the code ive written wait till ive given you all the docs i have 




Seller Onboarding + Endpoint Registration:

Wallet connect

Form to register endpoint + pricing

Save to DB

Display in dashboard






2. Environment Setup
Do you already have:

.env file with keys for wallet provider, facilitator URL, DB connection? yes

Supabase or PostgreSQL instance running? supabase

Local dev setup (Node, npm, Docker if needed)? yes im on codespace



using Coinbase’s facilitator directly

we’ll wire up:

/verify and /settle calls

Payload construction using x402 SDK



Seller Onboarding + Endpoint Registration:

Wallet connect

Form to register endpoint + pricing

Save to DB

Display in dashboard
